---
typora-root-url: ..
---

## 函数概述

![1.png](http://104.224.150.81:8080/images/2020/04/13/1.png)

## 用指针表示函数



 ![2.png](http://104.224.150.81:8080/images/2020/04/13/2.png)

```c
#include <stdio.h>
int main()
{
    int (*myshow)(const char *,...);//指针表示函数
    print("hellp world!\n");
    
    myshow = printf;
    
    myshow("==========\n");
    return 0;
}
//printf 本质上也是一个地址，只要找个标签指向指向这个地址就能运行。
```

举例子：

```c
//原函数写法
switch(day)
{
    case 1 :
        fun1();
    case 2 :
        fun2(); .....
}
//利用函数名就是地址的思想，写一个数组函数（类似一个数组但是存放的是函数的地址）
int (*p[7])(int,int);
p[0] = fun1;
p[1] = fun2;
//需要调用的时候
p[day](10,20);
//以此可以达到函数批量初始化的目的
```

## 输入参数

 值传递 

![](http://104.224.150.81:8080/images/2020/04/14/chrome_KQ9v30Fed8.png)

传递过程中不改变初始值，所以a的大小是不变的。

地址传递举例：

```c
#include <stdio.h>
void swap(int *a,int *b)
{
    int c;
    
    c = *a;
    *a = *b;
    *b = c;
}

int main()
{
    int a = 20;
    int b = 30;
    int c;
    
    printf("the a is %d,the b is %d\n",a,b);
    
    swap(&a,&b);
    
    printf("after swap the a is%d,the b is %d\n",a,b);
}
//直接传递了a与b的地址，如此可以做到函数中更改目标参数
```

![](http://104.224.150.81:8080/images/2020/04/14/chrome_x5rIEnEcQP.png)

注意 scanf要选择地址才能保存输入的数。

## 连续空间的传递

1.数组类型 通过标签传递数组的地址

![](http://104.224.150.81:8080/images/2020/04/14/chrome_n1WPma4VoB.png)

2.struct 结构体

![](http://104.224.150.81:8080/images/2020/04/14/chrome_Tcs1WQEtcE.png)

一般来说用指针进行传递，这样节省内存空间。

## 空间的读写问题

传递地址为了避免调用函数对不能修改的空间进行了修改采用const进行修饰来表示只读空间

![](http://104.224.150.81:8080/images/2020/04/14/chrome_x3bGCnlg6R.png)

补充：直接对数组进行初始化的方法 `sprintf`

![](http://104.224.150.81:8080/images/2020/04/14/chrome_82Pdyc9hHg.png)

## 字符空间与非字符空间

字符空间：

![](http://104.224.150.81:8080/images/2020/04/14/chrome_237aR2cHny.png)

处理时，寻找到有“\0”即为结束

![](http://104.224.150.81:8080/images/2020/04/14/chrome_4G3s5SgdbH.png)

非字符空间，没有结束标志，所以必须要声明大小

![](http://104.224.150.81:8080/images/2020/04/14/chrome_xnkl7QcOSd.png)

非字符串空间中可以用 `void *`这种形式来修饰，表示可以接收任意类型的地址。看到如上的修饰就要想到这肯定是非字符串空间。

![](http://104.224.150.81:8080/images/2020/04/14/chrome_OESxtSXF4o.png)

在函数使用了 `void *`之后，要对形参进行初始化。然后再对其进行调用。

# 返回值

![](http://104.224.150.81:8080/images/2020/04/14/chrome_U8F5IvlNCY.png)

返回类型：1.基本数据类型

​					2.指针类型

​					3.无法返回数组

![](http://104.224.150.81:8080/images/2020/04/14/chrome_yIXH5JrPlM.png)

```c
int *fun1(void)//开辟一个返回指针型的函数
int main()
{
    int *p;
    p = fun1();//返回一个指针
}

//类似的有：
void fun2(int **p)
int main()
{
    int *p;
    fun2(&p);
}
//int **p 可以看作int*(*p)传递一个指针给函数，用来实现用函数来更新二级指针的地址。
```

返回指针的方法，防止离开函数后被释放

```c
#include <stdio.h>
char *fun(void)
{
    static char buf[] = "hello world";//在静态区保存
    char *s = (char *)malloc(100);//在堆区保存
    return s;
}
int main()
{
    char *p;
    p = fun();
    printf("the p is %s\n",p);
    return 0;
}
```

