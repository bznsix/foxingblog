---
typora-root-url: ..
---

## C语言内存空间的使用

### 指针概述

![指针1](/pictures/C语言学习/指针1.png)

内存的读取方法由当时定义指针前面的变量进行选择。

例如：

```c
char *p;//此处定义的指针就是一次读取1个字节的数据
int *p;//此处定义的指针就是一次读取4个字节的数据
定义char *p容易连符号位一起读出造成错误，严谨写法应为
unsigned char *p;
```

### 指针＋修饰符

![指针2](/pictures/C语言学习/指针2.png)

```c
const char *p;//表示指针指示的内容不能变化，const修饰的是char *p
char * const p;//表示指针指向的地方不能变化，但是指向的地方里面的内容可以变化就和硬件资源的地址				 是固定的一样
```

关于const char *p的代码示例：

```c
#include <stdio.h>
int main()
{
    const char *p = "hello world!\n";
    char buf[] = {"hello world!\n"};
    char *p2 = buf;
    
    printf("the one is %x\n",*p);
    
    *p2 = 'a';
    
    printf("the %s\n",p2);//%s是字符串占位符遇到空格结束从指针P2开始读不加*注意
}
```

### typedef

![指针3](/pictures/C语言学习/指针3.png)

### 指针中的++，--



![指针4](/pictures/C语言学习/指针4.png)

### 按标签访问指针

![指针5](/pictures/C语言学习/指针5.png)

### 实例演示

char *p2 = (char *)&b;//强制指针类型转换

```c
#include <stdio.h>
int main()
{
  int a =0x12345678;
  int b =0x99999999;
  
  int *p1=&b;
  char *p2 = (char *)&b;
  
  printf("the p1+1 is %x,%x,%x\n",*(p1+1),p1[1],*p1+1);
  printf("the p2+1 is %x\n",*(p2+1));
}
```

注意C语言中的越界现象：例如p1[1000]此处有可能产生越界现象。